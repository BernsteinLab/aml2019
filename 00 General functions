### general functions, 20180105
### These functions are sourced at the beginning of other scripts for the aml2019 project.

message("cutf()")
cutf <- function(x, f=1, d="/") sapply(strsplit(x, d), function(i) paste(i[f], collapse=d))

message("scoreSignature.ref()")
scoreSignature.ref <- function(E, s, n=100, E.ref=NULL, E.ref.mean=NULL, verbose=FALSE) {
  if(verbose) {
    message("cells: ", ncol(E))
    message("genes: ", nrow(E))
    message("genes in signature: ", length(s))
    message("processing")
  }
  
  E.log <- log(E+1)   # uncentered values are used (change from previous version, but this should not make any difference)
  
  if(is.null(E.ref.mean)) {
    if(is.null(E.ref)) E.ref <- E     # only the average gene expression levels are needed from reference set to define a set of control genes of similar expression level for each gene in signature
    E.ref.mean <- log(rowMeans(E.ref)+1)
  }
  
  s.score <- colMeans(do.call(rbind, lapply(s, function(ss) {  # loop over each gene
    # ss <- s[2]
    # message(ss)
    if(verbose) message(".", appendLF = FALSE)
    ss.n <- names(sort(abs(E.ref.mean[ss] - E.ref.mean))[2:(n+1)])   # find n control genes with most similar average gene expression value
    E.log[ss, ] - colMeans(E.log[ss.n, ])   # substract average value of the n control genes
  })))
  if(verbose) message(" done")
  return(s.score)
}

message("scoreSignature.log()")
scoreSignature.log <- function(E, s, n=100, E.ref=NULL, E.ref.mean=NULL, verbose=FALSE) {
  if(verbose) {
    message("cells: ", ncol(E))
    message("genes: ", nrow(E))
    message("genes in signature: ", length(s))
    message("processing")
  }
  
  if(is.null(E.ref.mean)) {
    if(is.null(E.ref)) E.ref <- E     # only the average gene expression levels are needed from reference set to define a set of control genes of similar expression level for each gene in signature
    E.ref.mean <- rowMeans(E.ref)
  }
  
  s.score <- colMeans(do.call(rbind, lapply(s, function(ss) {  # loop over each gene
    if(verbose) message(".", appendLF = FALSE)
    ss.n <- names(sort(abs(E.ref.mean[ss] - E.ref.mean))[2:(n+1)])   # find n control genes with most similar average gene expression value
    E[ss, ] - colMeans(E[ss.n, ])   # substract average value of the n control genes
  })))
  if(verbose) message(" done")
  return(s.score)
}

message("plotTSNE()")
plotTSNE <- function(Y, centroid = FALSE, col = "black", xlab=NA, ylab=NA, xaxt="n", yaxt="n", ...) {
  Y.range <- apply(Y, 2, range)
  Y.diff <- apply(Y.range, 2, diff)
  Y.center <- apply(Y.range, 2, mean)
  
  par(mfrow=c(1, 1))
  par(mar=c(4, 4, 4, 4))
  plot(Y[, 1], Y[, 2], xlim=Y.center[1] + c(-0.5, 0.5)*max(Y.diff), ylim=Y.center[2] + c(-0.5, 0.5)*max(Y.diff), xlab=xlab, ylab=ylab, xaxt=xaxt, yaxt=yaxt, col=col, ...)
  
  if(centroid) {
    for(i in unique(col)) {
      i.w <- which(is.element(col, i))
      i.mean <- colMeans(Y[i.w, , drop=FALSE])
      lines(as.vector(rbind(Y[i.w, 1], i.mean[1], NA)), as.vector(rbind(Y[i.w, 2], i.mean[2], NA)), col=i)
      text(i.mean[1], i.mean[2], names(col)[match(i, col)])
    }
  }
}



## colors
message("colCustom()")
colCustom <- function(x, z=NULL, colors=c("#FFFFFF", "red")) {   # use grey to red as default
  if(is.null(z)) {   # just scale to min and max value
    x <- scaleMinMax(x, min(x, na.rm=TRUE), max(x, na.rm=TRUE))
  } else if(length(z) == 1) {   # zscore
    x <- scaleMinMax(x, z = z, keepwithin = TRUE)
  } else {  # scale to min max as provided
    x <- scaleMinMax(x, min = z[1], max = z[2], keepwithin = TRUE)
  }
  
  m <- is.na(x)
  x[m] <- 0.5
  r <- colorRamp(colors)(x)
  y <- apply(r, 1, function(rr) rgb(rr[1], rr[2], rr[3], maxColorValue = 255))
  y[m] <- NA
  y
}

message("colItay()")
colItay <- function(x, z=NULL) {
  colCustom(x, z=z, colors=rev(c("#660220", "#b01b2f", "#d46151", "#f2a585", "#fcdbc8", "#f7f7f7", "#d2e5ef", "#94c5dd", "#4794c1", "#2668aa", "#083160")))  # color pick from publication
}

message("colMatlab()")
colMatlab <- function(x, z=NULL) {
  colCustom(x, z=z, colors=c("blue", "cyan", "green", "yellow", "red"))
}

message("colCor()")
colCor <- function(x, z=NULL) {
  colCustom(x, z=z, colors=c("#FFFFFF", "#ffffcc", "#ffeda0", "#fed976", "#feb24c", "#fd8d3c", "#fc4e2a", "#e31a1c", "#bd0026", "#800026"))
}

message("col3()")
col3 <- function(x1, x2, x3, z=c(0, 1), white2grey = F) {
  # repeat if only one value given
  l <- max(c(length(x1), length(x2), length(x3)))
  if(length(x1) == 1 & l > 1) x1 <- rep(x1, l)
  if(length(x2) == 1 & l > 1) x2 <- rep(x2, l)
  if(length(x3) == 1 & l > 1) x3 <- rep(x3, l)
  
  # convert z to list if only two values are given
  if(!is.list(z)) z <- list(z, z, z)
  
  # missing values, change back to NA later
  mNA <- is.na(x1) | is.na(x2) | is.na(x3)
  x1[mNA] <- 0
  x2[mNA] <- 0
  x3[mNA] <- 0
  
  # scale to to min/max
  x1 <- scaleMinMax(x1, min=z[[1]][1], max=z[[1]][2], keepwithin=TRUE)
  x2 <- scaleMinMax(x2, min=z[[2]][1], max=z[[2]][2], keepwithin=TRUE)
  x3 <- scaleMinMax(x3, min=z[[3]][1], max=z[[3]][2], keepwithin=TRUE)
  
  # reverse
  x1 <- 1-x1
  x2 <- 1-x2
  x3 <- 1-x3
  
  # if all scores are low, replace with grey
  if(white2grey == T) {
    col.df <- data.frame(x1, x2, x3)
    col.df[apply(col.df, 1, min) >= 0.9,] <- c(0.95,0.95,0.95)
    x1 <- col.df$x1; x2 <- col.df$x2; x3 <- col.df$x3 }
  
  # convert to hex
  r <- rgb(x1, x2, x3)
  
  # put missing values back in
  r[mNA] <- NA
  
  # return
  return(r)
}
